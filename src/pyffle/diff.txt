1,38c1,3
< /*
< 	Space Manifold - a variety of tools for Kinect and FreeFrame
< 
< 	Copyright (c) 2011-2012 Tim Thompson <me@timthompson.com>
< 
< 	Permission is hereby granted, free of charge, to any person obtaining
< 	a copy of this software and associated documentation files
< 	(the "Software"), to deal in the Software without restriction,
< 	including without limitation the rights to use, copy, modify, merge,
< 	publish, distribute, sublicense, and/or sell copies of the Software,
< 	and to permit persons to whom the Software is furnished to do so,
< 	subject to the following conditions:
< 
< 	The above copyright notice and this permission notice shall be
< 	included in all copies or substantial portions of the Software.
< 
< 	Any person wishing to distribute modifications to the Software is
< 	requested to send the modifications to the original developer so that
< 	they can be incorporated into the canonical version.
< 
< 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
< 	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
< 	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
< 	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
< 	ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
< 	CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
< 	WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
< */
< 
< #include <FFGL.h>
< #include <FFGLLib.h>
< #include <stdint.h>
< 
< #include <iostream>
< #include <fstream>
< #include <strstream>
< #include <cstdlib> // for srand, rand
< #include <ctime>   // for time
---
> #include "NosuchDebug.h"
> #include "NosuchUtil.h"
> #include "ffutil.h"
50,51c15
< #include "NosuchException.h"
< #include "NosuchUtil.h"
---
> #include "Vizlet.h"
53,55c17
< #include "NosuchDebug.h"
< 
< #include <pthread.h>
---
> #include "NosuchOsc.h"
57,61c19,20
< // #define FFPARAM_BRIGHTNESS (0)
< 
< ////////////////////////////////////////////////////////////////////////////////////////////////////
< //  Plugin information
< ////////////////////////////////////////////////////////////////////////////////////////////////////
---
> #include "Sprite.h"
> #include "SpaceServer.h"
65c24
< 	"PY00",						// Plugin unique ID
---
> 	"V998",		// Plugin unique ID
72c31
< 	"Pyffle: Python FreeFrame Language Extension",	// Plugin description
---
> 	"Pyffle: a sample visual synth",	// description
76c35,36
< bool Pyffle::StaticInitialized = false;
---
> std::string PyfflePluginName = "dummyname";
> std::string PyffleDir = "dummydir";
78c38,39
< Pyffle* ThisPyffle = NULL;
---
> std::string vizlet_name() { return "Pyffle"; }
> CFFGLPluginInfo& vizlet_plugininfo() { return PluginInfo; }
80,92c41,42
< void Pyffle::StaticInitialization()
< {
< 	// Default debugging stuff
< 	// This currently duplicates the values in the definitions, but
< 	// eventually these values should come from an init file
< 
< 	NosuchDebug(1,"Pyffle StaticInitialization!");
< }
< 
< Pyffle::Pyffle() : CFreeFrameGLPlugin()
< {
< 	ThisPyffle = this;
< 	NosuchDebug(1,"Pyffle constructor this=%ld",(long)this);
---
> Pyffle::Pyffle() : Vizlet() {
> 	DEBUGPRINT(("Pyffle constructor"));
96,97d45
< 	_dopython = true;
< 	_python_disabled = false;
101,105c49,53
< 	initialized = false;
< 	gl_shutting_down = false;
< 
< 	width = 1.0f;
< 	height = 1.0f;
---
> 	_shutting_down = false;
> 	_dopython = true;
> 	_python_initialized = false;
> 	_python_disabled = false;
> 	_python_disable_on_exception = false;
115,116d62
< 	disabled = false;
< 	disable_on_exception = false;
119,123c65,138
< Pyffle::~Pyffle()
< {
< 	NosuchDebug(1,"Pyffle destructor called");
< 	// app_destroy();
< 	gl_shutting_down = true;
---
> Pyffle::~Pyffle() {
> }
> 
> DWORD __stdcall Pyffle::CreateInstance(CFreeFrameGLPlugin **ppInstance) {
> 	*ppInstance = new Pyffle();
> 	return (*ppInstance != NULL)? FF_SUCCESS : FF_FAIL;
> }
> 
> void Pyffle::processCursor(SpaceCursor* c, int downdragup) {
> 	// NO OpenGL calls here
> }
> 
> std::string Pyffle::processJson(std::string meth, cJSON *json, const char *id) {
> 	// NO OpenGL calls here
> 	throw NosuchException("Pyffle - Unrecognized method '%s'",meth.c_str());
> }
> 
> void Pyffle::processMidiInput(MidiMsg* m) {
> 	// NO OpenGL calls here
> }
> 
> void Pyffle::processMidiOutput(MidiMsg* m) {
> 	// NO OpenGL calls here
> }
> 
> bool Pyffle::python_initStuff() {
> 
> 	NosuchDebug(2,"_python_initStuff starts");
> 
> 	// test_stuff();
> 
> 	bool r = true;
> 	try {
> 		// static initializations
> 		if ( _dopython ) {
> 			if ( ! python_init() ) {
> 				NosuchDebug("python_init failed!");
> 			} else {
> 				NosuchDebug("python_init succeeded!");
> 			}
> 		}
> 	} catch (NosuchException& e) {
> 		NosuchDebug("NosuchException: %s",e.message());
> 		r = false;
> 	} catch (...) {
> 		// Does this really work?  Not sure
> 		NosuchDebug("Some other kind of exception occured!?");
> 		r = false;
> 	}
> 	NosuchDebug(2,"_python_initStuff returns %s\n",r?"true":"false");
> 	return r;
> }
> 
> bool Pyffle::processDraw() {
> 	// OpenGL calls here
> 
> 	if ( _shutting_down ) {
> 		return true;
> 	}
> 
> 	if ( ! _python_initialized ) {
> 		if ( ! python_initStuff() ) {
> 			NosuchDebug("initStuff failed, disabling plugin!");
> 			_python_disabled = true;
> 			return false;
> 		}
> 		_python_initialized = true;
> 	}
> 
> 	return true;
> }
> 
> void Pyffle::processDrawNote(MidiMsg* m) {
> 	// OpenGL calls here
131c146
< 		NosuchErrorOutput("Unable to find python function: %s",name);
---
> 		NosuchDebug("Unable to find python function: %s",name);
136a152,168
> bool
> Pyffle::python_change_processor(std::string behavename) {
> 
> 	if ( !(_processorObj = python_getProcessorObject(behavename))) {
> 		return FALSE;
> 	}
> 	if ( !(_processorDrawFunc = getpythonfunc(_processorObj, "processOpenGL")) ) {
> 		return FALSE;
> 	}
> 	return TRUE;
> }
> 
> void Pyffle::python_disable(std::string msg) {
> 	DEBUGPRINT(("python is being disabled!  msg=%s",msg.c_str()));
> 	_python_disabled = TRUE;
> }
> 
140c172
< 	lock_python();
---
> 	python_lock();
142c174
< 	unlock_python();
---
> 	python_unlock();
183,192c215,216
< 	if ( _processorDrawFunc == NULL ) {
< 		// This is expected when there's been
< 		// a syntax or execution error in the python code
< 		NosuchDebug(1,"_processorDrawFunc==NULL?");
< 		return "";
< 	}
< 	if ( _callBoundFunc == NULL ) {
< 		NosuchDebug("_callBoundFunc==NULL?");
< 		return "";
< 	}
---
> 	NosuchAssert(_callBoundFunc);
> 	NosuchAssert(_processorDrawFunc);
211,212d234
< 		NosuchDebug("Disabling drawing function for plugin=%s",PyfflePluginName.c_str());
< 		_processorDrawFunc = NULL;
220d241
< 	NosuchDebug(1,"python_getProcessorObject A");
227d247
< 	NosuchDebug(1,"python_getProcessorObject B btype=%s getProcessorFunc=%ld",b,(long)_getProcessorFunc);
234d253
< 	NosuchDebug(1,"python_getProcessorObject C");
239d257
< 	NosuchDebug(1,"python_getProcessorObject D");
243,254d260
< static PyObject* nosuchmedia_publicpath(PyObject* self, PyObject* args)
< {
<     const char* filename;
<  
<     if (!PyArg_ParseTuple(args, "s", &filename))
<         return NULL;
<  
< 	std::string path = PyfflePath(std::string(filename));
< 	NosuchDebug("(python) path= %s",path.c_str());
< 	return PyString_FromString(path.c_str());
< }
<  
282d287
<      {"publicpath", nosuchmedia_publicpath, METH_VARARGS, "Return path to a public file."},
288,289c293,294
< bool
< Pyffle::python_getUtilValues()
---
> std::string
> PyfflePath(std::string filepath)
291,305c296
< 	if (!(_recompileFunc = getpythonfunc(_PyffleUtilModule,"recompile"))) {
< 		python_disable("Can't get recompile function from pyffle module?!");
< 		return FALSE;
< 	}
< 
< 	if (!(_callBoundFunc=getpythonfunc(_PyffleUtilModule,"callboundfunc"))) {
< 		python_disable("Unable to find callboundfunc func");
< 		return FALSE;
< 	}
< 
< 	if (!(_getProcessorFunc=getpythonfunc(_PyffleUtilModule,"getprocessor"))) {
< 		python_disable("Unable to find getprocessor func");
< 		return FALSE;
< 	}
< 	return TRUE;
---
> 	return PyffleDir + "\\" + filepath;
320c311
<      (void) Py_InitModule("pyffle.builtin", PyffleMethods);
---
>      (void) Py_InitModule("pyffle", PyffleMethods);
326c317
< 			PyffleForwardSlash(NosuchFullPath("../python")).c_str()
---
> 			NosuchForwardSlash(PyfflePath("python")).c_str()
328d318
< 	NosuchDebug("Running script=%s",script.c_str());
331c321
< 	const char* pyffleutil = "pyffle.util";
---
> 	const char* pyffleutil = "pyffleutil";
342,349c332,333
< 	if ( !python_getUtilValues() ) {
< 		python_disable("Failed in python_getUtilValues");
< 		return FALSE;
< 	}
< 
< 	// Note: it's always pyffle, no matter what the Plugin name is, see comment above
< 	if ( python_recompileModule(pyffleutil) == FALSE ) {
< 		python_disable("Unable to recompile pyffle module");
---
> 	if (!(_recompileFunc = getpythonfunc(_PyffleUtilModule,"recompile"))) {
> 		python_disable("Can't get recompile function from pyffle module?!");
353,358c337,338
< 	// Not really sure this re-getting of the UtilValues is needed, or
< 	// makes a difference.  There's some kind of bug that happens occasionally
< 	// when there's an error (syntax or execution) in recompiling the module,
< 	// and this was an attempt to figure it out.
< 	if ( !python_getUtilValues() ) {
< 		python_disable("Failed in python_getUtilValues (second phase)");
---
> 	if (!(_callBoundFunc=getpythonfunc(_PyffleUtilModule,"callboundfunc"))) {
> 		python_disable("Unable to find callboundfunc func");
362,365c342,343
< 	if ( !python_change_processor(PyfflePluginName) ) {
< 		NosuchDebug("Unable to change processor to %s",PyfflePluginName.c_str());
< 		// No longer disable python when there's a problem in changing the processor.
< 		// python_disable(NosuchSnprintf("Unable to change processor to %s",PyfflePluginName.c_str()));
---
> 	if (!(_getProcessorFunc=getpythonfunc(_PyffleUtilModule,"getprocessor"))) {
> 		python_disable("Unable to find getprocessor func");
369,387c347,350
< 	return TRUE;
< }
< 
< bool
< Pyffle::python_change_processor(std::string behavename) {
< 
< 	PyObject *new_processorObj;
< 	PyObject *new_processorDrawFunc;
< 
< 	NosuchDebug("python_change_processor behavename=%s",behavename.c_str());
< 	if ( !(new_processorObj = python_getProcessorObject(behavename))) {
< 		NosuchDebug("python_getProcessorObject returned NULL!");
< 		// _processorObj = NULL;
< 		_processorDrawFunc = NULL;
< 		return FALSE;
< 	}
< 	if ( !(new_processorDrawFunc = getpythonfunc(new_processorObj, "processOpenGL")) ) {
< 		// _processorObj = NULL;
< 		_processorDrawFunc = NULL;
---
> 	NosuchDebug(1,"Trying to recompile pyffle.");
> 	// Note: it's always pyffle, no matter what the Plugin name is, see comment above
> 	if ( python_recompileModule(pyffleutil) == FALSE ) {
> 		python_disable("Unable to recompile pyffle module");
389a353
> 	NosuchDebug(1,"recompile pyffle worked. changing processor to %s",PyfflePluginName.c_str());
391,405c355,356
< 	// _processorObj = new_processorObj;
< 	_processorDrawFunc = new_processorDrawFunc;
< 	return TRUE;
< }
< 
< void Pyffle::python_disable(std::string msg) {
< 	NosuchErrorOutput("python is being disabled!  msg=%s",msg.c_str());
< 	_python_disabled = TRUE;
< }
< 
< bool Pyffle::python_reloadPyffleUtilModule() {
< 
< 	PyObject* newmod = PyImport_ReloadModule(_PyffleUtilModule);
< 	if ( newmod == NULL) {
< 		python_disable("Unable to reload pyffle module");
---
> 	if ( !python_change_processor(PyfflePluginName) ) {
> 		python_disable(NosuchSnprintf("Unable to get change processor to %s",PyfflePluginName.c_str()));
408d358
< 	_PyffleUtilModule = newmod;
413,600c363
< int Pyffle::python_runfile(std::string filename) {
< 	std::string fullpath = PyfflePath("python") + "\\" + filename;
< 	std::ifstream f(fullpath.c_str(), std::ifstream::in);
< 	if ( ! f.is_open() ) {
< 		NosuchErrorOutput("Unable to open python file: %s",fullpath.c_str());
< 		return 1;
< 	}
< 	std::string contents;
< 	std::string line;
< 	while (!std::getline(f,line,'\n').eof()) {
< 		contents += (line+"\n");
< 	}
< 	f.close();
< 	int r = PyRun_SimpleString(contents.c_str());
< 	if ( r != 0 ) {
< 		NosuchErrorOutput("Error executing contents of: %s",fullpath.c_str());
< 	}
< 	return r;
< }
< 
< static bool
< istrue(std::string s)
< {
< 	return(s == "true" || s == "True" || s == "1");
< }
< 
< void Pyffle::_initialize() {
< 	NosuchDebug("Pyffle::_initialize start");
< 	if ( _dopython ) {
< 		if ( ! python_init() ) {
< 			NosuchDebug("python_init failed!");
< 		} else {
< 			NosuchDebug("python_init succeeded!");
< 			NosuchDebug("NosuchDebug python_init succeeded!");
< 		}
< 	}
< }
< 
< #if 0
< bool Pyffle::enable_mmtt()
< {
< 	if ( _mmtt ) {
< 		NosuchDebug("Hey, Pyffle::enableMmtt called when it's already enabled!?");
< 		return true;
< 	}
< 	NosuchDebug("About to call app_create for this=%ld",(long)this);
< 	if ( ThisApp ) {
< 		NosuchDebug("NOT calling app_create because ThisApp is non-NULL");
< 	} else {
< 		app_create(0,NULL);
< 		_mmtt = ThisApp;
< 		app_execute("set_drawmode","{ \"mode\": \"python\" }");
< 	}
< 	return true;
< }
< #endif
< 
< bool Pyffle::initStuff() {
< 
< 	NosuchDebug(2,"initStuff starts");
< 
< 	bool r = true;
< 	try {
< 		// static initializations
< 		Pyffle::_initialize();
< 	} catch (NosuchException& e) {
< 		NosuchDebug("NosuchException: %s",e.message());
< 		r = false;
< 	} catch (...) {
< 		// Does this really work?  Not sure
< 		NosuchDebug("Some other kind of exception occured!?");
< 		r = false;
< 	}
< 	NosuchDebug(2,"initStuff returns %s\n",r?"true":"false");
< 	return r;
< }
< 
< DWORD Pyffle::ProcessOpenGL(ProcessOpenGLStruct *pGL)
< {
< 	if ( gl_shutting_down ) {
< 		return FF_SUCCESS;
< 	}
< 	if ( disabled ) {
< 		return FF_SUCCESS;
< 	}
< 
< 	if ( ! initialized ) {
< 		if ( ! initStuff() ) {
< 			NosuchDebug("initStuff failed, disabling plugin!");
< 			disabled = true;
< 			return FF_FAIL;
< 		}
< 		initialized = true;
< 	}
< 
< #if 0
< 	if ( _mmtt ) {
< 		app_update();
< 	}
< #endif
< 
< #ifdef FRAMELOOPINGTEST
< 	static int framenum = 0;
< 	static bool framelooping = FALSE;
< #endif
< 
< 	if ( _passthru ) {
< 		if (pGL->numInputTextures<1)
< 			return FF_FAIL;
< 
< 		if (pGL->inputTextures[0]==NULL)
< 			return FF_FAIL;
<   
< 		FFGLTextureStruct &Texture = *(pGL->inputTextures[0]);
< 
< 		//bind the texture handle
< 		glBindTexture(GL_TEXTURE_2D, Texture.Handle);
< 	}
< 
< #ifdef DOITINPYTHON
< 	glDisable(GL_TEXTURE_2D); 
< 
< 	glEnable(GL_BLEND); 
< 	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); 
< 	glLineWidth((GLfloat)3.0f);
< #endif
< 
< 	bool gotexception = false;
< 	try {
< 		CATCH_NULL_POINTERS;
< 
< 		NosuchDebug(2,"ProcessOpenGL");
< 		if ( _dopython && ! _python_disabled ) {
< 			python_draw();
< 		}
< 	} catch (NosuchException& e ) {
< 		NosuchDebug("NosuchException in python_draw : %s",e.message());
< 		gotexception = true;
< 	} catch (...) {
< 		NosuchDebug("UNKNOWN Exception in python_draw!");
< 		gotexception = true;
< 	}
< 
< 	if ( gotexception && disable_on_exception ) {
< 		NosuchDebug("DISABLING Pyffle due to exception!!!!!");
< 		disabled = true;
< 	}
< 
< #if 0
< 	if ( _mmtt ) {
< 		app_draw();
< 	}
< #endif
< 
< 	glDisable(GL_BLEND); 
< 	glEnable(GL_TEXTURE_2D); 
< 
< #ifdef FRAMELOOPINGTEST
< 	int w = Texture.Width;
< 	int h = Texture.Height;
< #define NFRAMES 300
< 	static GLubyte* pixelArray[NFRAMES];
< 	if ( framelooping ) {
< 		glRasterPos2i(-1,-1);
< 		glDrawPixels(w,h,GL_RGB,GL_UNSIGNED_BYTE,pixelArray[framenum]);
< 		framenum = (framenum+1)%NFRAMES;
< 	} else {
< 		if ( framenum < NFRAMES ) {
< 			pixelArray[framenum] = new GLubyte[w*h*3];
< 			glReadPixels(0,0,w,h,GL_RGB,GL_UNSIGNED_BYTE,pixelArray[framenum]);
< 			framenum++;
< 		} else {
< 			framelooping = TRUE;
< 			framenum = 0;
< 		}
< 	}
< #endif
< 
< 	//disable texturemapping
< 	glDisable(GL_TEXTURE_2D);
< 	
< 	//restore default color
< 	glColor4f(1.f,1.f,1.f,1.f);
< 	
< 	return FF_SUCCESS;
< }
< 
< void Pyffle::lock_python() {
---
> void Pyffle::python_lock() {
603,604c366,367
< #ifdef PYFFLE_LOCK
< 	PyffleLock(&python_mutex,"python");
---
> #ifdef NOSUCH_LOCK
> 	NosuchLock(&python_mutex,"python");
608,610c371,373
< void Pyffle::unlock_python() {
< #ifdef PYFFLE_LOCK
< 	PyffleUnlock(&python_mutex,"python");
---
> void Pyffle::python_unlock() {
> #ifdef NOSUCH_LOCK
> 	NosuchUnlock(&python_mutex,"python");
612,719d374
< }
< 
< DWORD Pyffle::GetParameter(DWORD dwIndex)
< {
< 	return FF_FAIL;  // no parameters
< }
< 
< DWORD Pyffle::SetParameter(const SetParameterStruct* pParam)
< {
< 	return FF_FAIL;  // no parameters
< }
< std::string
< PyffleForwardSlash(std::string filepath) {
< 	size_t i;
< 	while ( (i=filepath.find("\\")) != filepath.npos ) {
< 		filepath.replace(i,1,"/");
< 	}
< 	return filepath;
< }
< 
< std::string PyfflePublicDir = "";
< std::string PyfflePluginName = "";
< std::string PyfflePythonDir = "";
< 
< std::string
< PyfflePath(std::string filepath)
< {
< 	return PyfflePublicDir + "\\Pyffle\\" + filepath;
< }
< 
< std::string
< PyfflePublicPath(std::string filepath)
< {
< 	return PyfflePublicDir + "\\" + filepath;
< }
< 
< extern "C" {
< 
< bool
< ffgl_setdll(std::string dllpath)
< {
< 	// No longer convert entire string to lowercase, because the plugin names are case-sensitive
< 	// dllpath = NosuchToLower(dllpath);
< 
< 	size_t lastslash = dllpath.find_last_of("/\\");
< 	size_t lastunder = dllpath.find_last_of("_");
< 	size_t lastdot = dllpath.find_last_of(".");
< 	std::string suffix = (lastdot==dllpath.npos?"":dllpath.substr(lastdot));
< 
< 	if ( NosuchToLower(suffix) != ".dll"
< 		|| lastslash == dllpath.npos
< 		|| lastunder == dllpath.npos
< 		|| lastdot == dllpath.npos ) {
< 
< 		NosuchDebug("Hey! dll name (%s) isn't of the form */Pyffle_Name.dll, PLUGIN IS NOW DISABLED!",dllpath.c_str());
< 		return FALSE;
< 	}
< 
< 	std::string look_for_prefix = "pyffle_";
< 	int look_for_len = look_for_prefix.size();
< 
< 	std::string dir = dllpath.substr(0,lastslash);
< 	std::string prefix = dllpath.substr(lastslash+1,lastdot-lastslash-1);
< 	if ( NosuchToLower(prefix.substr(0,look_for_len)) != look_for_prefix ) {
< 		NosuchDebug("Hey! plugin name name (%s) isn't of the form */Pyffle_Name.dll, PLUGIN IS NOW DISABLED!",dllpath.c_str());
< 		return FALSE;
< 	}
< 
< 	PyfflePluginName = prefix.substr(look_for_len);  // i.e. remove the pyffle_
< 	size_t i = PyfflePluginName.find("_debug");
< 	if ( i > 0 ) {
< 		PyfflePluginName = PyfflePluginName.substr(0,i);
< 	}
< 	// PyffleDebugPrefix = "Pyffle_"+PyfflePluginName+": ";
< 	PyfflePublicDir = dir;
< 	PyfflePythonDir = dir + "\\python";
< 
< 	NosuchCurrentDir = dir;
< 
< 	NosuchDebugSetLogDirFile(dir,"debug.txt");
< 
< 	NosuchDebug(1,"Setting PyfflePublicDir = %s",PyfflePublicDir.c_str());
< 
< 	struct _stat statbuff;
< 	int e = _stat(PyfflePublicDir.c_str(),&statbuff);
< 	if ( ! (e == 0 && (statbuff.st_mode | _S_IFDIR) != 0) ) {
< 		NosuchDebug("Hey! No directory %s!?",PyfflePublicDir.c_str());
< 		return FALSE;
< 	}
< 
< 	char id[5];
< 	// Compute a hash of the plugin name and use two 4-bit values
< 	// from it to produce the last 2 characters of the unique ID.
< 	// It's possible there will be a collision.
< 	int hash = 0;
< 	for ( const char* p = PyfflePluginName.c_str(); *p!='\0'; p++ ) {
< 		hash += *p;
< 	}
< 	id[0] = 'P';
< 	id[1] = 'Y';
< 	id[2] = 'A' + (hash & 0xf);
< 	id[3] = 'A' + ((hash >> 4) & 0xf);
< 	id[4] = '\0';
< 	PluginInfo.SetPluginIdAndName(id,("Pyffle_"+PyfflePluginName).c_str());
< 
< 	return TRUE;
< }
< 
